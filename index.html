<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Neon Maze Runner - Ultra Graphics</title>
    <style>
        body { margin: 0; background: #020008; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; font-family: 'Courier New', Courier, monospace; }
        #ui { color: #fff; font-size: 28px; margin-bottom: 10px; text-shadow: 0 0 10px #00d4ff, 0 0 20px #00d4ff; z-index: 10; display: flex; gap: 30px; align-items: center; }
        #container { position: relative; border: 4px solid #333; box-shadow: 0 0 50px rgba(0, 212, 255, 0.2); }
        canvas { background: #000; z-index: 5; position: relative; }
        /* スキャンライン（走査線）効果 */
        #container::after {
            content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 3px, 3px 100%; pointer-events: none; z-index: 10;
        }
        #bgCanvas { position: fixed; top: 0; left: 0; z-index: 1; width: 100vw; height: 100vh; }
        #game-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: #fff; }
        .btn { padding: 15px 30px; font-size: 20px; cursor: pointer; background: #00d4ff; color: #000; border: none; font-weight: bold; transition: 0.3s; box-shadow: 0 0 20px #00d4ff; }
        .btn:hover { background: #fff; box-shadow: 0 0 40px #fff; }
        #click-to-start { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #020008; color: #00d4ff; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200; cursor: pointer; text-shadow: 0 0 15px #00d4ff; }
    </style>
</head>
<body>
    <div id="click-to-start">
        <h1 style="font-size: 50px;">NEON MAZE RUNNER</h1>
        <p>[ CLICK TO INITIALIZE SYSTEM ]</p>
    </div>
    <div id="ui">
        <span>SCORE: <span id="score">0</span></span>
        <button id="mute-btn" style="background:none; border:1px solid #00d4ff; color:#00d4ff; cursor:pointer;">SOUND: ON</button>
    </div>
    <div id="container">
        <canvas id="bgCanvas"></canvas>
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="game-overlay">
        <h1 id="overlay-text" style="font-size: 70px; text-shadow: 0 0 30px #ff00ff;">SYSTEM HALT</h1>
        <button class="btn" onclick="location.reload()">REBOOT</button>
    </div>

<script>
// --- Configuration & Assets ---
const PATH = 'assets/sounds/';
const SOUND_FILES = { bgm: PATH+'bgm.mp3', warp: PATH+'warp.mp3', powerup: PATH+'powerup.mp3', eatGhost: PATH+'eat_ghost.mp3', win: PATH+'win.mp3' };
let audioCtx, masterGain, bgmSource, isMuted = false, sounds = {};

const tileSize = 32, rows = 19, cols = 19;
let score = 0, powerMode = false, powerTimer = 0, gameActive = false, stepCounter = 0, lastTime = 0;
const PLAYER_PIXEL_SPEED = 130, GHOST_PIXEL_SPEED = 105;

// パーティクル配列
let particles = [];

const maze = [];
const leftMap = [
    [1,1,1,1,1,1,1,1,1,1], [1,2,0,0,0,1,0,0,0,1], [1,0,1,1,0,1,0,1,0,1], 
    [1,0,0,0,0,0,0,1,0,1], [1,0,1,1,0,1,1,1,0,1], [1,0,0,0,0,0,0,0,0,0], 
    [1,1,1,1,0,1,1,1,1,1], [1,1,1,1,0,1,-1,-1,-1,-1], [1,1,1,1,0,1,-1,1,1,-1], 
    [-1,-1,-1,-1,-1,-1,-1,1,-1,-1], [1,1,1,1,0,1,-1,1,1,1], [1,1,1,1,0,1,-1,-1,-1,-1], 
    [1,0,0,0,0,1,0,1,1,1], [1,0,1,1,0,0,0,0,0,0], [1,0,0,0,0,1,1,1,0,1], 
    [1,1,1,1,0,0,0,0,0,0], [1,0,0,0,0,1,0,1,0,1], [1,2,1,1,0,0,0,0,0,1], [1,1,1,1,1,1,1,1,1,1]  
];
for(let r=0; r<rows; r++) {
    const row = [...leftMap[r], ...leftMap[r].slice(0, 9).reverse()];
    maze.push(row);
}

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = cols * tileSize; canvas.height = rows * tileSize;

const player = { x: 9 * tileSize, y: 13 * tileSize, dx: 0, dy: 0, nextDx: 0, nextDy: 0 };
const ghosts = [
    { x: 9 * tileSize, y: 9 * tileSize, dx: 0, dy: -1, color: "#ff2d55", type: "chase" },
    { x: 9 * tileSize, y: 7 * tileSize, dx: 0, dy: -1, color: "#ff9500", type: "random" }
];

// --- Systems ---
async function initAudio() {
    // AudioContextの作成（エラー回避のためtry-catch）
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain(); 
        masterGain.connect(audioCtx.destination);
    } catch(e) {
        console.warn("AudioContext could not be initialized", e);
        return; // オーディオがダメでも次へ進む
    }

    // 各音源の読み込み（一つずつ独立してtry-catch）
    const loadPromises = Object.entries(SOUND_FILES).map(async ([key, url]) => {
        try {
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(`Not Found: ${url}`);
            const buf = await resp.arrayBuffer();
            sounds[key] = await audioCtx.decodeAudioData(buf);
        } catch (e) {
            console.warn(`Sound load failed: ${key}. Background processing will continue.`);
        }
    });

    // 全ての読み込み試行が終わるのを待つ（成否に関わらず進む）
    await Promise.all(loadPromises);

    // BGMの開始
    if (sounds.bgm && !isMuted) {
        try {
            bgmSource = audioCtx.createBufferSource(); 
            bgmSource.buffer = sounds.bgm;
            bgmSource.loop = true; 
            bgmSource.connect(masterGain); 
            bgmSource.start(0);
        } catch(e) { console.error("BGM start failed", e); }
    }
}

function playExtSound(name) { if (sounds[name] && !isMuted) { const s = audioCtx.createBufferSource(); s.buffer = sounds[name]; s.connect(masterGain); s.start(0); } }

function createParticles(x, y, color) {
    for (let i = 0; i < 8; i++) {
        particles.push({
            x, y, color,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 1.0
        });
    }
}

// --- Drawing ---
function drawGame() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // Wall Bloom
    ctx.shadowBlur = 15;
    for (let r=0; r<rows; r++) {
        for (let c=0; c<cols; c++) {
            let x=c*tileSize, y=r*tileSize, t=maze[r][c];
            if (t===1) {
                ctx.strokeStyle = "#00d4ff";
                ctx.shadowColor = "#00d4ff";
                ctx.lineWidth = 3;
                ctx.strokeRect(x+6, y+6, 20, 20);
            } else if (t===0) {
                ctx.fillStyle = "#fff";
                ctx.shadowBlur = 5;
                ctx.beginPath(); ctx.arc(x+16, y+16, 2, 0, 7); ctx.fill();
            } else if (t===2) {
                ctx.fillStyle = "#fff";
                ctx.shadowBlur = 20;
                ctx.shadowColor = "#fff";
                ctx.beginPath(); ctx.arc(x+16, y+16, 6 + Math.sin(stepCounter*0.1)*2, 0, 7); ctx.fill();
            }
        }
    }

    // Particles
    ctx.shadowBlur = 0;
    particles = particles.filter(p => p.life > 0);
    particles.forEach(p => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.02;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 3, 3);
    });
    ctx.globalAlpha = 1.0;

    // Player (Glow)
    ctx.shadowBlur = 20; ctx.shadowColor = "#ff0";
    ctx.fillStyle = "#ff0";
    ctx.beginPath(); ctx.arc(player.x+16, player.y+16, 13, (0.2+Math.sin(stepCounter*0.3)*0.1)*Math.PI, (1.8-Math.sin(stepCounter*0.3)*0.1)*Math.PI);
    ctx.lineTo(player.x+16, player.y+16); ctx.fill();

    // Ghosts
    ghosts.forEach(g => {
        const gColor = powerMode ? (powerTimer<180 && Math.floor(powerTimer/10)%2===0 ? "#fff":"#004cff") : g.color;
        ctx.shadowColor = gColor; ctx.shadowBlur = 20;
        ctx.fillStyle = gColor;
        ctx.beginPath(); ctx.arc(g.x+16, g.y+14, 13, Math.PI, 0); ctx.fillRect(g.x+3, g.y+14, 26, 14); ctx.fill();
        // Eyes
        ctx.fillStyle = "#fff"; ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.arc(g.x+10, g.y+12, 4, 0, 7); ctx.arc(g.x+22, g.y+12, 4, 0, 7); ctx.fill();
    });
    ctx.shadowBlur = 0;
}

// 背景グリッド（強化版）
const bgCanvas = document.getElementById("bgCanvas");
const bctx = bgCanvas.getContext("2d");
function drawBackground() {
    bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
    bctx.fillStyle = "#020008"; bctx.fillRect(0,0,bgCanvas.width,bgCanvas.height);
    const time = performance.now() * 0.001;
    bctx.strokeStyle = "#ff00ff"; bctx.lineWidth = 1;
    for(let i=0; i<20; i++) {
        bctx.globalAlpha = (i/20) * 0.3;
        let y = bgCanvas.height/2 + Math.pow(i, 2) * 2 + (time*50 % 50);
        bctx.beginPath(); bctx.moveTo(0, y); bctx.lineTo(bgCanvas.width, y); bctx.stroke();
    }
    for(let i=-10; i<=10; i++) {
        bctx.globalAlpha = 0.2;
        bctx.beginPath(); bctx.moveTo(bgCanvas.width/2, bgCanvas.height/2);
        bctx.lineTo(bgCanvas.width/2 + i * 200, bgCanvas.height); bctx.stroke();
    }
}

// --- Logic ---
function isWall(tx, ty, isGhost) {
    if (ty < 0 || ty >= rows) return true;
    if (tx < 0 || tx >= cols) return ty === 9 ? isGhost : true;
    if (isGhost && ty === 9 && (tx === 0 || tx === cols-1)) return true;
    return maze[ty][tx] === 1;
}

function updateEntity(ent, speed, isGhost) {
    const prevX = ent.x, prevY = ent.y;
    ent.x += ent.dx * speed; ent.y += ent.dy * speed;
    const tx = Math.round(ent.x/tileSize), ty = Math.round(ent.y/tileSize);
    const cx = tx*tileSize, cy = ty*tileSize;

    if ((prevX<cx && ent.x>=cx) || (prevX>cx && ent.x<=cx) || (prevY<cy && ent.y>=cy) || (prevY>cy && ent.y<=cy) || (ent.dx===0 && ent.dy===0)) {
        ent.x = cx; ent.y = cy;
        if (!isGhost) {
            if (tx < 0) { ent.x = (cols-1)*tileSize; playExtSound('warp'); }
            else if (tx >= cols) { ent.x = 0; playExtSound('warp'); }
            const curTx = Math.round(ent.x/tileSize);
            if (curTx >= 0 && curTx < cols) {
                if (maze[ty][curTx] === 0) { 
                    maze[ty][curTx] = -1; score += 10; 
                    createParticles(ent.x+16, ent.y+16, "#fff");
                }
                if (maze[ty][curTx] === 2) { 
                    maze[ty][curTx] = -1; score += 50; powerMode = true; powerTimer = 720; 
                    playExtSound('powerup');
                }
            }
            if (!isWall(curTx+ent.nextDx, ty+ent.nextDy, false)) { ent.dx = ent.nextDx; ent.dy = ent.nextDy; }
            else if (isWall(curTx+ent.dx, ty+ent.dy, false)) { ent.dx = 0; ent.dy = 0; }
        } else {
            const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
            const back = {x:-ent.dx, y:-ent.dy};
            let valid = dirs.filter(d => !isWall(tx+d.x, ty+d.y, true) && (d.x!==back.x || d.y!==back.y));
            if (valid.length === 0) valid = [back];
            valid.sort((a,b) => {
                const distA = Math.hypot((tx+a.x)*tileSize-player.x, (ty+a.y)*tileSize-player.y);
                const distB = Math.hypot((tx+b.x)*tileSize-player.x, (ty+b.y)*tileSize-player.y);
                return powerMode ? distB - distA : distA - distB;
            });
            ent.dx = valid[0].x; ent.dy = valid[0].y;
        }
    }
}

function loop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;
    drawBackground();
    if (gameActive) {
        updateEntity(player, PLAYER_PIXEL_SPEED * dt, false);
        if (powerMode) { powerTimer--; if (powerTimer <= 0) powerMode = false; }
        ghosts.forEach(g => {
            updateEntity(g, (powerMode ? GHOST_PIXEL_SPEED * 0.5 : GHOST_PIXEL_SPEED) * dt, true);
            if (Math.hypot(player.x-g.x, player.y-g.y) < 22) {
                if (powerMode) { 
                    createParticles(g.x+16, g.y+16, g.color);
                    g.x=9*tileSize; g.y=9*tileSize; score+=200; playExtSound('eatGhost');
                } else { gameActive=false; document.getElementById("game-overlay").style.display="flex"; }
            }
        });
        if (!maze.flat().includes(0) && !maze.flat().includes(2)) { 
            gameActive=false; playExtSound('win'); 
            document.getElementById("overlay-text").innerText="SYSTEM RECOVERED";
            document.getElementById("game-overlay").style.display="flex"; 
        }
    }
    drawGame(); document.getElementById("score").innerText = score;
    stepCounter++; requestAnimationFrame(loop);
}

document.getElementById("click-to-start").addEventListener('click', async (e) => {
    const splash = e.currentTarget;
    splash.style.pointerEvents = "none"; // 二重クリック防止
    splash.querySelector('p').innerText = "INITIALIZING...";

    // オーディオ初期化を待つが、失敗してもゲームは始める
    try {
        await initAudio();
    } catch(e) {
        console.error("Audio init error:", e);
    }

    splash.style.display = "none"; 
    gameActive = true;
    lastTime = performance.now();
});

document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") { player.nextDx = 0; player.nextDy = -1; }
    if (e.key === "ArrowDown") { player.nextDx = 0; player.nextDy = 1; }
    if (e.key === "ArrowLeft") { player.nextDx = -1; player.nextDy = 0; }
    if (e.key === "ArrowRight") { player.nextDx = 1; player.nextDy = 0; }
});
requestAnimationFrame(loop);
</script>
</body>
</html>

