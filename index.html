<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Neon Maze Runner - Recovery Build</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; font-family: sans-serif; }
        #ui { color: #fff; font-size: 24px; margin-bottom: 10px; z-index: 10; }
        #container { position: relative; border: 2px solid #00d4ff; background: #000; }
        canvas { display: block; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; color: #ff00ff; font-weight: bold; font-size: 24px; z-index: 100; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; }
    </style>
</head>
<body>
    <div id="overlay">CLICK TO START</div>
    <div id="ui">SCORE: <span id="score">0</span></div>
    <div id="container">
        <canvas id="gameCanvas"></canvas>
    </div>

<script>
// --- 音源設定 ---
const PATH = 'assets/sounds/';
const SOUND_FILES = { bgm: PATH+'bgm.mp3', warp: PATH+'warp.mp3', powerup: PATH+'powerup.mp3', eatGhost: PATH+'eat_ghost.mp3', win: PATH+'win.mp3' };
let audioCtx, masterGain, bgmSource, isMuted = false, sounds = {};

// --- ゲームデータ ---
const tileSize = 32, rows = 19, cols = 19;
let score = 0, powerMode = false, powerTimer = 0, gameActive = false, stepCounter = 0, lastTime = 0;
let particles = [];

const leftMap = [
    [1,1,1,1,1,1,1,1,1,1], [1,2,0,0,0,1,0,0,0,1], [1,0,1,1,0,1,0,1,0,1], 
    [1,0,0,0,0,0,0,1,0,1], [1,0,1,1,0,1,1,1,0,1], [1,0,0,0,0,0,0,0,0,0], 
    [1,1,1,1,0,1,1,1,1,1], [1,1,1,1,0,1,-1,-1,-1,-1], [1,1,1,1,0,1,-1,1,1,-1], 
    [-1,-1,-1,-1,-1,-1,-1,1,-1,-1], [1,1,1,1,0,1,-1,1,1,1], [1,1,1,1,0,1,-1,-1,-1,-1], 
    [1,0,0,0,0,1,0,1,1,1], [1,0,1,1,0,0,0,0,0,0], [1,0,0,0,0,1,1,1,0,1], 
    [1,1,1,1,0,0,0,0,0,0], [1,0,0,0,0,1,0,1,0,1], [1,2,1,1,0,0,0,0,0,1], [1,1,1,1,1,1,1,1,1,1]  
];
const maze = leftMap.map(row => [...row, ...row.slice(0, 9).reverse()]);

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = cols * tileSize; canvas.height = rows * tileSize;

const player = { x: 9 * tileSize, y: 13 * tileSize, dx: 0, dy: 0, nextDx: 0, nextDy: 0 };
const ghosts = [
    { x: 9 * tileSize, y: 9 * tileSize, dx: 0, dy: -1, color: "#ff4d4d" },
    { x: 9 * tileSize, y: 7 * tileSize, dx: 0, dy: -1, color: "#ffb852" }
];

// --- サウンド関数 ---
async function initAudio() {
    try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        masterGain = audioCtx.createGain();
        masterGain.connect(audioCtx.destination);
        Object.entries(SOUND_FILES).forEach(async ([key, url]) => {
            try {
                const r = await fetch(url);
                if(r.ok) {
                    const b = await r.arrayBuffer();
                    sounds[key] = await audioCtx.decodeAudioData(b);
                    if(key === 'bgm') playBGM();
                }
            } catch(e) {}
        });
    } catch(e) {}
}
function playBGM() { if(sounds.bgm && audioCtx) { bgmSource = audioCtx.createBufferSource(); bgmSource.buffer = sounds.bgm; bgmSource.loop = true; bgmSource.connect(masterGain); bgmSource.start(0); } }
function playExtSound(n) { if(sounds[n] && audioCtx) { const s = audioCtx.createBufferSource(); s.buffer = sounds[n]; s.connect(masterGain); s.start(0); } }

// --- 描画関数 ---
function draw() {
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 迷路
    ctx.shadowBlur = 10; ctx.shadowColor = "#00d4ff";
    for (let r=0; r<rows; r++) {
        for (let c=0; c<cols; c++) {
            let x=c*tileSize, y=r*tileSize, t=maze[r][c];
            if (t===1) { ctx.strokeStyle="#00d4ff"; ctx.lineWidth=2; ctx.strokeRect(x+5,y+5,22,22); }
            else if (t===0) { ctx.fillStyle="#fff"; ctx.beginPath(); ctx.arc(x+16,y+16,2,0,7); ctx.fill(); }
            else if (t===2) { ctx.fillStyle="#fff"; ctx.shadowBlur=15; ctx.beginPath(); ctx.arc(x+16,y+16,6,0,7); ctx.fill(); }
        }
    }

    // パーティクル
    ctx.shadowBlur = 0;
    particles = particles.filter(p => p.life > 0);
    particles.forEach(p => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.02;
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 2, 2);
    });
    ctx.globalAlpha = 1.0;

    // キャラクター
    ctx.shadowBlur = 15; ctx.shadowColor = "#ff0"; ctx.fillStyle="#ff0";
    ctx.beginPath(); ctx.arc(player.x+16, player.y+16, 12, (0.2+Math.sin(stepCounter*0.3)*0.1)*Math.PI, (1.8-Math.sin(stepCounter*0.3)*0.1)*Math.PI); ctx.lineTo(player.x+16, player.y+16); ctx.fill();
    
    ghosts.forEach(g => {
        let col = powerMode ? (powerTimer<120 && Math.floor(powerTimer/10)%2===0 ? "#fff":"#00f") : g.color;
        ctx.shadowBlur = 15; ctx.shadowColor = col; ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(g.x+16, g.y+14, 12, Math.PI, 0); ctx.fillRect(g.x+4, g.y+14, 24, 14); ctx.fill();
    });
    ctx.shadowBlur = 0;
}

// --- ロジック ---
function isWall(tx, ty) {
    if (ty < 0 || ty >= rows) return true;
    if (tx < 0 || tx >= cols) return ty !== 9; 
    return maze[ty][tx] === 1;
}

function update(dt) {
    if (!gameActive) return;

    // Player Update
    const prevX = player.x, prevY = player.y;
    player.x += player.dx * 125 * dt; player.y += player.dy * 125 * dt;
    const tx = Math.round(player.x/tileSize), ty = Math.round(player.y/tileSize);
    const cx = tx*tileSize, cy = ty*tileSize;

    if (Math.abs(player.x - cx) < 4 && Math.abs(player.y - cy) < 4) {
        player.x = cx; player.y = cy;
        if (tx < 0) { player.x = (cols-1)*tileSize; playExtSound('warp'); }
        else if (tx >= cols) { player.x = 0; playExtSound('warp'); }
        const curTx = Math.round(player.x/tileSize);
        if (curTx >= 0 && curTx < cols) {
            if (maze[ty][curTx] === 0) { maze[ty][curTx] = -1; score += 10; }
            if (maze[ty][curTx] === 2) { maze[ty][curTx] = -1; score += 50; powerMode = true; powerTimer = 720; playExtSound('powerup'); }
        }
        if (!isWall(curTx+player.nextDx, ty+player.nextDy)) { player.dx = player.nextDx; player.dy = player.nextDy; }
        else if (isWall(curTx+player.dx, ty+player.dy)) { player.dx = 0; player.dy = 0; }
    }

    if (powerMode) { powerTimer--; if (powerTimer <= 0) powerMode = false; }
    
    // Ghosts (簡易版)
    ghosts.forEach(g => {
        g.x += g.dx * (powerMode ? 50:100) * dt; g.y += g.dy * (powerMode ? 50:100) * dt;
        if (Math.hypot(player.x-g.x, player.y-g.y) < 20) {
            if (powerMode) { g.x = 9*tileSize; g.y = 9*tileSize; score += 200; playExtSound('eatGhost'); }
            else { gameActive = false; location.reload(); }
        }
        if (Math.random() < 0.02) {
            const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
            const d = dirs[Math.floor(Math.random()*4)];
            if (!isWall(Math.round(g.x/tileSize)+d.x, Math.round(g.y/tileSize)+d.y)) { g.dx = d.x; g.dy = d.y; }
        }
    });
}

function loop(t) {
    const dt = (t - lastTime) / 1000;
    lastTime = t;
    update(isNaN(dt) ? 0 : dt);
    draw();
    document.getElementById("score").innerText = score;
    stepCounter++;
    requestAnimationFrame(loop);
}

document.getElementById("overlay").onclick = function() {
    this.style.display = "none";
    gameActive = true;
    initAudio();
};

document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") { player.nextDx = 0; player.nextDy = -1; }
    if (e.key === "ArrowDown") { player.nextDx = 0; player.nextDy = 1; }
    if (e.key === "ArrowLeft") { player.nextDx = -1; player.nextDy = 0; }
    if (e.key === "ArrowRight") { player.nextDx = 1; player.nextDy = 0; }
});

requestAnimationFrame(loop);
</script>
</body>
</html>
