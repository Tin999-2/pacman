<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Neon Maze Runner - Glow & Particles</title>
    <style>
        body { margin: 0; background: #050010; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; font-family: sans-serif; }
        #ui { color: #fff; font-size: 28px; margin-bottom: 10px; text-shadow: 0 0 15px #00d4ff; z-index: 10; display: flex; gap: 20px; align-items: center; }
        #container { position: relative; border: 2px solid #00d4ff; box-shadow: 0 0 20px rgba(0, 212, 255, 0.5); }
        canvas { background: rgba(0,0,0,0.9); z-index: 5; display: block; }
        #bgCanvas { position: fixed; top: 0; left: 0; z-index: 1; pointer-events: none; width: 100vw; height: 100vh; }
        #game-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
        #game-overlay h1 { color: #fff; font-size: 60px; text-shadow: 0 0 20px #00d4ff; margin-bottom: 20px; }
        #click-to-start { position: fixed; color: #ff00ff; font-weight: bold; font-size: 24px; z-index: 200; background: #050010; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; text-shadow: 0 0 10px #ff00ff; }
    </style>
</head>
<body>
    <div id="click-to-start">
        <span>READY? [ CLICK TO START ]</span>
        <small style="font-size: 12px; margin-top: 10px; color: #00d4ff;">Assets: assets/sounds/</small>
    </div>
    <div id="ui">
        <span>SCORE: <span id="score">0</span></span>
        <button id="mute-btn" style="background:none; border:1px solid #fff; color:#fff; cursor:pointer; padding:5px 10px;">SOUND: ON</button>
    </div>
    <div id="container">
        <canvas id="bgCanvas"></canvas>
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="game-overlay">
        <h1 id="overlay-text">GAME OVER</h1>
        <button onclick="location.reload()" style="padding:10px 20px; cursor:pointer;">RETRY</button>
    </div>

<script>
// --- 音源設定 ---
const PATH = 'assets/sounds/';
const SOUND_FILES = { bgm: PATH+'bgm.mp3', warp: PATH+'warp.mp3', powerup: PATH+'powerup.mp3', eatGhost: PATH+'eat_ghost.mp3', win: PATH+'win.mp3' };
let audioCtx, masterGain, bgmSource, isMuted = false, sounds = {};

async function initAudio() {
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain(); masterGain.connect(audioCtx.destination);
        for (const [key, url] of Object.entries(SOUND_FILES)) {
            try {
                const resp = await fetch(url);
                const buf = await resp.arrayBuffer();
                sounds[key] = await audioCtx.decodeAudioData(buf);
            } catch (e) { console.warn("Missing sound:", key); }
        }
        if (sounds.bgm && !isMuted) {
            bgmSource = audioCtx.createBufferSource(); bgmSource.buffer = sounds.bgm;
            bgmSource.loop = true; bgmSource.connect(masterGain); bgmSource.start(0);
        }
    } catch(e) { console.error("Audio init failed"); }
}

function playExtSound(name) { if (sounds[name] && !isMuted) { const s = audioCtx.createBufferSource(); s.buffer = sounds[name]; s.connect(masterGain); s.start(0); } }

// --- ゲーム設定 ---
const tileSize = 32, rows = 19, cols = 19;
let score = 0, powerMode = false, powerTimer = 0, gameActive = false, stepCounter = 0, lastTime = 0;
let particles = []; // パーティクル配列

const leftMap = [
    [1,1,1,1,1,1,1,1,1,1], [1,2,0,0,0,1,0,0,0,1], [1,0,1,1,0,1,0,1,0,1], 
    [1,0,0,0,0,0,0,1,0,1], [1,0,1,1,0,1,1,1,0,1], [1,0,0,0,0,0,0,0,0,0], 
    [1,1,1,1,0,1,1,1,1,1], [1,1,1,1,0,1,-1,-1,-1,-1], [1,1,1,1,0,1,-1,1,1,-1], 
    [-1,-1,-1,-1,-1,-1,-1,1,-1,-1], [1,1,1,1,0,1,-1,1,1,1], [1,1,1,1,0,1,-1,-1,-1,-1], 
    [1,0,0,0,0,1,0,1,1,1], [1,0,1,1,0,0,0,0,0,0], [1,0,0,0,0,1,1,1,0,1], 
    [1,1,1,1,0,0,0,0,0,0], [1,0,0,0,0,1,0,1,0,1], [1,2,1,1,0,0,0,0,0,1], [1,1,1,1,1,1,1,1,1,1]  
];
const maze = leftMap.map(row => [...row, ...row.slice(0, 9).reverse()]);

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = cols * tileSize; canvas.height = rows * tileSize;

const PLAYER_PIXEL_SPEED = 125, GHOST_PIXEL_SPEED = 105;
const player = { x: 9 * tileSize, y: 13 * tileSize, dx: 0, dy: 0, nextDx: 0, nextDy: 0 };
const ghosts = [
    { x: 9 * tileSize, y: 9 * tileSize, dx: 0, dy: -1, color: "#ff4d4d", type: "chase" },
    { x: 9 * tileSize, y: 7 * tileSize, dx: 0, dy: -1, color: "#ffb852", type: "random" }
];

function createParticles(x, y, color) {
    for (let i = 0; i < 6; i++) {
        particles.push({ x, y, color, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 1.0 });
    }
}

function drawGame() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // 迷路の描画（グロー効果付き）
    ctx.shadowBlur = 10; ctx.shadowColor = "#00d4ff";
    for (let r=0; r<rows; r++) {
        for (let c=0; c<cols; c++) {
            let x=c*tileSize, y=r*tileSize, t=maze[r][c];
            if (t===1) { ctx.strokeStyle="#00d4ff"; ctx.lineWidth=2; ctx.strokeRect(x+5,y+5,22,22); }
            else if (t===0) { ctx.fillStyle="#fff"; ctx.shadowBlur=5; ctx.beginPath(); ctx.arc(x+16,y+16,2,0,7); ctx.fill(); }
            else if (t===2) { ctx.fillStyle="#fff"; ctx.shadowBlur=15; ctx.beginPath(); ctx.arc(x+16,y+16,6,0,7); ctx.fill(); }
        }
    }

    // パーティクルの更新と描画
    ctx.shadowBlur = 0;
    particles = particles.filter(p => p.life > 0);
    particles.forEach(p => {
        p.x += p.vx; p.y += p.vy; p.life -= 0.02;
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 2, 2);
    });
    ctx.globalAlpha = 1.0;

    // プレイヤー
    ctx.shadowBlur = 15; ctx.shadowColor = "#ff0"; ctx.fillStyle="#ff0";
    ctx.beginPath(); ctx.arc(player.x+16, player.y+16, 12, (0.2+Math.sin(stepCounter*0.3)*0.1)*Math.PI, (1.8-Math.sin(stepCounter*0.3)*0.1)*Math.PI); ctx.lineTo(player.x+16, player.y+16); ctx.fill();

    // ゴースト
    ghosts.forEach(g => {
        let col = powerMode ? (powerTimer<120 && Math.floor(powerTimer/10)%2===0 ? "#fff":"#00f") : g.color;
        ctx.shadowBlur = 15; ctx.shadowColor = col; ctx.fillStyle = col;
        ctx.beginPath(); ctx.arc(g.x+16, g.y+14, 12, Math.PI, 0); ctx.fillRect(g.x+4, g.y+14, 24, 14); ctx.fill();
    });
    ctx.shadowBlur = 0;
}

// ロジック部分は「治った」と言われた安定版を維持
function isWall(tx, ty, isGhost) {
    if (ty < 0 || ty >= rows) return true;
    if (tx < 0 || tx >= cols) return ty === 9 ? isGhost : true;
    if (isGhost && ty === 9 && (tx === 0 || tx === cols-1)) return true;
    return maze[ty][tx] === 1;
}

function updateEntity(ent, speed, isGhost) {
    const prevX = ent.x, prevY = ent.y;
    ent.x += ent.dx * speed; ent.y += ent.dy * speed;
    const tx = Math.round(ent.x/tileSize), ty = Math.round(ent.y/tileSize);
    const cx = tx*tileSize, cy = ty*tileSize;
    if ((prevX<cx && ent.x>=cx) || (prevX>cx && ent.x<=cx) || (prevY<cy && ent.y>=cy) || (prevY>cy && ent.y<=cy) || (ent.dx===0 && ent.dy===0)) {
        ent.x = cx; ent.y = cy;
        if (!isGhost) {
            if (tx < 0) { ent.x = (cols-1)*tileSize; playExtSound('warp'); }
            else if (tx >= cols) { ent.x = 0; playExtSound('warp'); }
            const curTx = Math.round(ent.x/tileSize);
            if (curTx >= 0 && curTx < cols) {
                if (maze[ty][curTx] === 0) { maze[ty][curTx] = -1; score += 10; createParticles(ent.x+16, ent.y+16, "#fff"); }
                if (maze[ty][curTx] === 2) { maze[ty][curTx] = -1; score += 50; powerMode = true; powerTimer = 720; playExtSound('powerup'); }
            }
            if (!isWall(curTx+ent.nextDx, ty+ent.nextDy, false)) { ent.dx = ent.nextDx; ent.dy = ent.nextDy; }
            else if (isWall(curTx+ent.dx, ty+ent.dy, false)) { ent.dx = 0; ent.dy = 0; }
        } else {
            const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
            const back = {x:-ent.dx, y:-ent.dy};
            let valid = dirs.filter(d => !isWall(tx+d.x, ty+d.y, true) && (d.x!==back.x || d.y!==back.y));
            if (valid.length === 0) valid = [back];
            valid.sort((a,b) => {
                const distA = Math.hypot((tx+a.x)*tileSize-player.x, (ty+a.y)*tileSize-player.y);
                const distB = Math.hypot((tx+b.x)*tileSize-player.x, (ty+b.y)*tileSize-player.y);
                return powerMode ? distB - distA : distA - distB;
            });
            ent.dx = valid[0].x; ent.dy = valid[0].y;
        }
    }
}

const bgCanvas = document.getElementById("bgCanvas");
const bctx = bgCanvas.getContext("2d");
function drawBackground() {
    bgCanvas.width = window.innerWidth; bgCanvas.height = window.innerHeight;
    bctx.fillStyle = "#050010"; bctx.fillRect(0,0,bgCanvas.width,bgCanvas.height);
}

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;
    drawBackground();
    if (gameActive) {
        updateEntity(player, PLAYER_PIXEL_SPEED * dt, false);
        if (powerMode) { powerTimer--; if (powerTimer <= 0) powerMode = false; }
        ghosts.forEach(g => {
            updateEntity(g, (powerMode ? GHOST_PIXEL_SPEED * 0.5 : GHOST_PIXEL_SPEED) * dt, true);
            if (Math.hypot(player.x-g.x, player.y-g.y) < 22) {
                if (powerMode) { createParticles(g.x+16, g.y+16, g.color); g.x=9*tileSize; g.y=9*tileSize; score+=200; playExtSound('eatGhost'); }
                else { gameActive=false; document.getElementById("game-overlay").style.display="flex"; }
            }
        });
        if (!maze.flat().includes(0) && !maze.flat().includes(2)) { gameActive=false; playExtSound('win'); document.getElementById("overlay-text").innerText="YOU WIN!"; document.getElementById("game-overlay").style.display="flex"; }
    }
    drawGame(); document.getElementById("score").innerText = score;
    stepCounter++; requestAnimationFrame(loop);
}

document.getElementById("click-to-start").addEventListener('click', async (e) => {
    e.currentTarget.style.pointerEvents = "none";
    await initAudio(); e.currentTarget.style.display = "none"; gameActive = true;
    lastTime = performance.now();
});
document.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") { player.nextDx = 0; player.nextDy = -1; }
    if (e.key === "ArrowDown") { player.nextDx = 0; player.nextDy = 1; }
    if (e.key === "ArrowLeft") { player.nextDx = -1; player.nextDy = 0; }
    if (e.key === "ArrowRight") { player.nextDx = 1; player.nextDy = 0; }
});
requestAnimationFrame(loop);
</script>
</body>
</html>
